
***Функция*** - логически обособленный блок кода, который может принимать аргументы и возвращать значение

```c
// О.ф.
возвращаемый_тип имя(список формальных параметров)
{
   // тело ф-ии
}


возвращаемый_тип - только скалярные типы (нельзя возвращать массивы)
```


```c
#include <stdio.h>

int sum(int a, int b) // a, b - формальные пар-ры
{
	return a + b;  // return - осуществляет возврат в точку вызова
}


int main()
{
	int x = 1, y = 2;
	printf("%d\n", sum(x, y)); // x, y - аргументы
}
```



## Передача аргументов по значению и по ссылке

- всё передаётся по значению - при вызове ф-ии **значения** агрументов *копируются* в формальные параметры

```c
#include <stdio.h>

int sum(int a, int b)
{
	a += b;
	return a;
}

int main()
{
	int x = 1, y = 2;
	printf("%d\n", sum(x, y));  // 3
	printf("%d\n", x);          // 1
}
```

- передача по ссылке реализуется с помощью передачи значения указателя

```c
#include <stdio.h>

int sum(int *a, int b)
{
	*a += b;
	return *a;
}

int main()
{
	int x = 1, y = 2;
	printf("%d\n", sum(&x, y));  // 3
	printf("%d\n", x);           // 3
}
```

## Области видимости

1. Файл   начало файла - конец файла 
2. Блок    `{` `}`
3. Функция - *только для меток*



```c
// функция, не возвращающая значение
void hello()
{
	printf("Hello!\n");
}
```


## Рекурсия

Рекурсивные ф-ии - ф-ии, которые вызывают себя

Рекурсивная ф-я содержит 2 обзательные ветви:
- рекурсивная
- терминальная


$n! = 1 * 2 * 3 * ... * n$

$n! = (n-1)! * n$



```c
int factorial_r(int n)
{
	return n > 1 ? factorial_r(n - 1) * n : n;
}


int factorial_l(int n)
{
	int result = 1;
	for (int i = 2; i <= n; i++)
		result *= i;
	return result; 
}

```


![[Функции 2024-10-12 15.16.28.excalidraw]]